"""
12865번 평범한 배낭

1.  0/1 knapsack 문제.
    어떤 분할되지 않는 가치-무게를 지닌 물건들을 w만큼의 무게한도를 가진 배낭에 넣을 때
    최대 가치를 지니도록 만드는 문제.
    
2.  만약 물건들이 분해되어 단위 무게로 쪼개질 수 있다면 그리디로 푸는 것이 일반적이겠으나,
    분해되지 않는 조건이므로 그리디의 부분 최적이 전체 최적일 수가 없다.
    따라서, 물건을 넣었을 때/넣지 않았을 때로 구분해 경우의 수를 따지는 DP가 적용된다.
    
3.  * P[i, w] = 현재 w만큼의 배낭 무게 한도를 가질 때 i개의 물건으로 만들 수 있는 최대 가치
    어떤 배낭에 현재 w만큼 물건을 더 넣을 수 있다고 할 때 물건 (v, w_i)를 넣으려고 한다고 생각한다면
    넣을 수 있다/넣을 수 없다 의 2가지 행동의 수가 생긴다.
    1)  w >= w_i여서 넣을 수 있는 경우
        이 경우 물건을 넣을 수 있는 데, 이 물건을 넣지 않고 무게 w를 맞춘 경우의 가치와 이 물건을 넣지 않고
        무게 w-w_i를 맞춘 경우의 가치에 물건의 가치를 더한 것 중 더 큰 값을 선택한다.
        이것을 점화식으로 표현하면 P[i, w] = max(P[i-1][w-w_i]+v_i, P[i-1][w])
    2)  w < w_i여서 넣을 수 없는 경우
        이 경우에 물건을 넣을 수 없으므로, 물건을 제외한 i-1개의 물건들로 w 한도에 넣을 수 있는 최대 가치가
        곧 최대의 가치가 된다.
        이것을 점화식으로 표현하면 P[i, w] = P[i-1][w]
"""

N, K = map(int, input().split())

items = [list(map(int, input().split())) for _ in range(N)]


def packing():
    table = [[0] * (K + 1) for _ in range(N + 1)]

    for i in range(1, N + 1):
        for j in range(1, K + 1):
            if items[i - 1][0] <= j:
                table[i][j] = max(
                    table[i - 1][j - items[i - 1][0]] + items[i - 1][1], table[i - 1][j]
                )
            else:
                table[i][j] = table[i - 1][j]

    print(table[i][j])


packing()
